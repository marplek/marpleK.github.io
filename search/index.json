[{"content":"在Node.js中，工廠模式 (Factory Design Pattern)的主要的優點有\n 解耦對象的創建和實現：工廠模式允許我們將物件(object)的創建過程與其具體的實現分開。這意味著，如果需要更改物件的實現方式，只需更改工廠函數，而不需要修改使用該物件的其他代碼。 動態創建對象：工廠模式允許在運行時基於特定條件動態地創建物件。例如，根據配置或環境變量，可以選擇返回不同的物件實例。 封裝：工廠模式可以利用JavaScript的閉包特性來實現封裝，確保某些對象的內部細節不被外部訪問。 提供一致的接口：工廠模式確保所有從工廠返回的物件都有一致的接口，這使得使用這些物件的代碼更加簡單和可預測。 簡化代碼和提高可維護性：由於物件的創建邏輯被集中在一個地方，因此更容易進行更改和維護。 靈活性：工廠模式提供了很大的靈活性，允許輕鬆地添加新的物件類型或更改現有物件的實現方式。 更好的控制物件的生命週期：工廠模式允許更細緻地控制物件的創建和初始化過程，例如，可以在物件被返回之前進行一些額外的設置或檢查。  例如，需要創建Image，\n比起直接創建Image的類，\n這樣的方式幾乎把物件的創建方式定死了\n1  const image = new Image(name)   使用工廠模式會比用new還要靈活。\n1 2 3 4  function createImage (name) { return new Image(name) } const image = createImage(\u0026#39;photo.jpeg\u0026#39;)   此外，Factory模式還允許我們暴露出比類更小的\u0026quot;表面積\u0026quot;被擴展或使用，提供了一種更靈活、更健壯的方法來創建物件，並允許開發者在不修改現有代碼的情況下進行重構或擴展功能。\n範例 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45  // 定義不同的圖像類型 class ImageJpeg { constructor(name) { this.name = name; this.format = \u0026#39;jpeg\u0026#39;; } } class ImageGif { constructor(name) { this.name = name; this.format = \u0026#39;gif\u0026#39;; } } class ImagePng { constructor(name) { this.name = name; this.format = \u0026#39;png\u0026#39;; } } // 創建工廠函數 function createImage(name) { if (name.match(/\\.jpe?g$/)) { return new ImageJpeg(name); } else if (name.match(/\\.gif$/)) { return new ImageGif(name); } else if (name.match(/\\.png$/)) { return new ImagePng(name); } else { throw new Error(\u0026#39;不支持的格式\u0026#39;); } } // 使用工廠函數 const image1 = createImage(\u0026#39;photo.jpeg\u0026#39;); console.log(image1.format); // 輸出: jpeg  const image2 = createImage(\u0026#39;animation.gif\u0026#39;); console.log(image2.format); // 輸出: gif  const image3 = createImage(\u0026#39;icon.png\u0026#39;); console.log(image3.format); // 輸出: png    封裝 Factory模式不僅僅是用於創建對象，它還可以用作封裝的一種機制。封裝是物件導向的四大基本原則之一，指的是隱藏對象的內部狀態和實現細節，只暴露必要的操作和方法給外部使用。\n以下是一個範例，展示如何使用Factory模式來實現封裝：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32  function createPerson(name) { // 私有屬性  const privateProperties = { age: 25 }; // 公開的對象  const person = { setName(newName) { if (!newName) { throw new Error(\u0026#39;名稱不能為空\u0026#39;); } name = newName; }, getName() { return name; }, getAge() { return privateProperties.age; } }; return person; } const john = createPerson(\u0026#39;John\u0026#39;); console.log(john.getName()); // 輸出: John console.log(john.getAge()); // 輸出: 25  // 不能直接訪問或修改私有屬性 // john.age 或 john.privateProperties.age 都是undefined    createPerson工廠函數內部有一個privateProperties對象，它存儲了私有屬性。外部無法直接訪問這些私有屬性，只能通過公開的方法來訪問。這就是封裝的一個簡單實現，它確保了對象的內部狀態和實現細節不會被外部代碼直接訪問或修改。\n","date":"2023-03-05T00:00:00Z","permalink":"https://blog.marplek.online/p/node.js-%E5%B7%A5%E5%BB%A0%E6%A8%A1%E5%BC%8F-factory-design-pattern/","title":"Node.js 工廠模式 (Factory Design Pattern)"},{"content":"原理：  當一條從點出發的射線與多邊形交點為奇數時，該點在多邊形內；若為偶數，則在多邊形外。  判斷相交 統一使用向右的水平射線\n 先考慮兩點式的直線方程。給定兩個點 (x1, y1) 和 (x2, y2)，直線的方程可以表示為: $y - y1 = \\frac{y2 - y1}{x2 - x1} (x - x1)$ 兩個點是 s_poi (起點) 和 e_poi (終點)。所以方程可以寫成: $y - s_{poi}[1] = \\frac{e_{poi}[1] - s_{poi}[1]}{e_{poi}[0] - s_{poi}[0]} (x - s_{poi}[0])$ 由於要找的是與水平射線相交的點，所以這個射線的 y 坐標是固定的，等於 poi[1]。將這個值帶入上述的方程中取代 y，我們可以解出 x，也就是交點的 x 坐標。 帶入後整理，可以得到: $x = s_{poi}[0] + \\frac{poi[1] - s_{poi}[1]}{e_{poi}[1] - s_{poi}[1]} (e_{poi}[0] - s_{poi}[0])$  交點在射線起點右側則為相交 交點在射線起點左側則為不相交\n特殊情況   重疊 重疊需要判斷為有兩個點相交，兩個點相交相當於不影響結果，直接排除即可。\n  射線經過多邊形交點 相交的算式會判斷成有兩個點相交，遇到這種情況，排除經過下端點。\n  線段長度為0\n  以c++實現 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37  #include \u0026lt;iostream\u0026gt;#include \u0026lt;vector\u0026gt; struct Point { double x; double y; }; bool point_in_polygon(Point point, std::vector\u0026lt;Point\u0026gt; polygon) { int polygon_length = polygon.size(); int j = polygon_length - 1; bool is_in_polygon = false; for (int i = 0; i \u0026lt; polygon_length; i++) { if (((polygon[i].y \u0026lt; point.y \u0026amp;\u0026amp; polygon[j].y \u0026gt;= point.y) || (polygon[j].y \u0026lt; point.y \u0026amp;\u0026amp; polygon[i].y \u0026gt;= point.y)) \u0026amp;\u0026amp; (polygon[i].x \u0026lt;= point.x || polygon[j].x \u0026lt;= point.x)) { if (polygon[i].x + (point.y - polygon[i].y) / (polygon[j].y - polygon[i].y) * (polygon[j].x - polygon[i].x) \u0026lt; point.x) { is_in_polygon = !is_in_polygon; } } j = i; } return is_in_polygon; } int main() { Point point = {2.5, 3.5}; std::vector\u0026lt;Point\u0026gt; polygon = {{1, 1}, {1, 4}, {4, 4}, {4, 1}}; bool is_in_polygon = point_in_polygon(point, polygon); std::cout \u0026lt;\u0026lt; \u0026#34;Is point in polygon? \u0026#34; \u0026lt;\u0026lt; (is_in_polygon ? \u0026#34;Yes\u0026#34; : \u0026#34;No\u0026#34;) \u0026lt;\u0026lt; std::endl; return 0; }   以python實現 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16  def point_in_polygon(point, polygon): polygon_length = len(polygon) j = polygon_length - 1 is_in_polygon = False for i in range(polygon_length): if ((polygon[i][1] \u0026lt; point[1] and polygon[j][1] \u0026gt;= point[1]) or (polygon[j][1] \u0026lt; point[1] and polygon[i][1] \u0026gt;= point[1])) and \\ (polygon[i][0] \u0026lt;= point[0] or polygon[j][0] \u0026lt;= point[0]): if polygon[i][0] + (point[1] - polygon[i][1]) / (polygon[j][1] - polygon[i][1]) * (polygon[j][0] - polygon[i][0]) \u0026lt; point[0]: is_in_polygon = not is_in_polygon j = i return is_in_polygon   總結    時間複雜度 空間複雜度     O(n) O(1)    優點：\n 簡單且直觀。 對於複雜的多邊形也適用。 計算效率高。  缺點：\n 需要考慮多種特殊情況，以確保結果的正確性。  應用：\n 圖形編輯軟體中的點選功能。 地理資訊系統中的地區查詢。  ","date":"2019-03-05T00:00:00Z","permalink":"https://blog.marplek.online/p/%E5%88%A4%E6%96%B7%E9%BB%9E%E6%98%AF%E5%90%A6%E5%9C%A8%E5%A4%9A%E9%82%8A%E5%BD%A2%E5%85%A7/","title":"判斷點是否在多邊形內"}]