[{"content":"原理：  當一條從點出發的射線與多邊形交點為奇數時，該點在多邊形內；若為偶數，則在多邊形外。  判斷相交 統一使用向右的水平射線\n 先考慮兩點式的直線方程。給定兩個點 (x1, y1) 和 (x2, y2)，直線的方程可以表示為: $y - y1 = \\frac{y2 - y1}{x2 - x1} (x - x1)$ 兩個點是 s_poi (起點) 和 e_poi (終點)。所以方程可以寫成: $y - s_{poi}[1] = \\frac{e_{poi}[1] - s_{poi}[1]}{e_{poi}[0] - s_{poi}[0]} (x - s_{poi}[0])$ 由於要找的是與水平射線相交的點，所以這個射線的 y 坐標是固定的，等於 poi[1]。將這個值帶入上述的方程中取代 y，我們可以解出 x，也就是交點的 x 坐標。 帶入後整理，可以得到: $x = s_{poi}[0] + \\frac{poi[1] - s_{poi}[1]}{e_{poi}[1] - s_{poi}[1]} (e_{poi}[0] - s_{poi}[0])$  交點在射線起點右側則為相交 交點在射線起點左側則為不相交\n特殊情況   重疊 重疊需要判斷為有兩個點相交，兩個點相交相當於不影響結果，直接排除即可。\n  射線經過多邊形交點 相交的算式會判斷成有兩個點相交，遇到這種情況，排除經過下端點。\n  線段長度為0\n  以c++實現 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37  #include \u0026lt;iostream\u0026gt;#include \u0026lt;vector\u0026gt; struct Point { double x; double y; }; bool point_in_polygon(Point point, std::vector\u0026lt;Point\u0026gt; polygon) { int polygon_length = polygon.size(); int j = polygon_length - 1; bool is_in_polygon = false; for (int i = 0; i \u0026lt; polygon_length; i++) { if (((polygon[i].y \u0026lt; point.y \u0026amp;\u0026amp; polygon[j].y \u0026gt;= point.y) || (polygon[j].y \u0026lt; point.y \u0026amp;\u0026amp; polygon[i].y \u0026gt;= point.y)) \u0026amp;\u0026amp; (polygon[i].x \u0026lt;= point.x || polygon[j].x \u0026lt;= point.x)) { if (polygon[i].x + (point.y - polygon[i].y) / (polygon[j].y - polygon[i].y) * (polygon[j].x - polygon[i].x) \u0026lt; point.x) { is_in_polygon = !is_in_polygon; } } j = i; } return is_in_polygon; } int main() { Point point = {2.5, 3.5}; std::vector\u0026lt;Point\u0026gt; polygon = {{1, 1}, {1, 4}, {4, 4}, {4, 1}}; bool is_in_polygon = point_in_polygon(point, polygon); std::cout \u0026lt;\u0026lt; \u0026#34;Is point in polygon? \u0026#34; \u0026lt;\u0026lt; (is_in_polygon ? \u0026#34;Yes\u0026#34; : \u0026#34;No\u0026#34;) \u0026lt;\u0026lt; std::endl; return 0; }   以python實現 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16  def point_in_polygon(point, polygon): polygon_length = len(polygon) j = polygon_length - 1 is_in_polygon = False for i in range(polygon_length): if ((polygon[i][1] \u0026lt; point[1] and polygon[j][1] \u0026gt;= point[1]) or (polygon[j][1] \u0026lt; point[1] and polygon[i][1] \u0026gt;= point[1])) and \\ (polygon[i][0] \u0026lt;= point[0] or polygon[j][0] \u0026lt;= point[0]): if polygon[i][0] + (point[1] - polygon[i][1]) / (polygon[j][1] - polygon[i][1]) * (polygon[j][0] - polygon[i][0]) \u0026lt; point[0]: is_in_polygon = not is_in_polygon j = i return is_in_polygon   總結    時間複雜度 空間複雜度     O(n) O(1)    優點：\n 簡單且直觀。 對於複雜的多邊形也適用。 計算效率高。  缺點：\n 需要考慮多種特殊情況，以確保結果的正確性。  應用：\n 圖形編輯軟體中的點選功能。 地理資訊系統中的地區查詢。  ","date":"2019-03-05T00:00:00Z","permalink":"https://blog.marplek.online/p/%E5%88%A4%E6%96%B7%E9%BB%9E%E6%98%AF%E5%90%A6%E5%9C%A8%E5%A4%9A%E9%82%8A%E5%BD%A2%E5%85%A7/","title":"判斷點是否在多邊形內"}]